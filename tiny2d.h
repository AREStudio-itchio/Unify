/*
PD: No mantengas la licencia en tu código fuente, aquí la dejo para que no necesites añadirla a mano.
PS: No keep the license in your source code, here I leave it so you don't need to add it manually.

Copyright 2026 AREStudio

BSL-1.0 License

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#pragma once
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdbool.h>
#include <math.h>
#include <stdio.h>   // Para snprintf
#include <string.h>  // Para strcmp y strlen
#include <mmsystem.h>
#pragma comment(lib, "winmm.lib")

// --- Tipos y colores ---
typedef struct { int x, y, w, h; } Rect;
typedef struct { float x, y; } Vec2;

static struct {
    COLORREF BLACK, WHITE, RED, GREEN, BLUE, YELLOW, CYAN, MAGENTA, GRAY, ORANGE;
} color = {
    RGB(0,0,0), RGB(255,255,255), RGB(255,0,0), RGB(0,255,0), RGB(0,0,255),
    RGB(255,255,0), RGB(0,255,255), RGB(255,0,255), RGB(128,128,128), RGB(255,165,0)
};

// --- Estado interno ---
static HWND hwnd = NULL;
static HDC hdcWindow = NULL;
static HDC hdcBuffer = NULL;
static HBITMAP hbmBuffer = NULL;
static int screenWidth = 640, screenHeight = 480;
static bool shouldClose = false;
static bool keys[256] = {0};
static bool prevKeys[256] = {0};
static int baseWidth = 0;
static int baseHeight = 0;

static bool isFullscreen = false;

static int windowedX = 0, windowedY = 0;
static int windowedW = 0, windowedH = 0;

// --- Hooks del usuario ---
extern bool tiny2D_Update(float dt);
extern bool tiny2D_Init();

void DrawPixel(int x, int y, COLORREF color);
void DrawLine(int x1, int y1, int x2, int y2, COLORREF color);
void DrawRect(int x, int y, int w, int h, COLORREF color);
void DrawCircle(int cx, int cy, int radius, COLORREF color);
void DrawText2D(const char* text, int x, int y, COLORREF textColor);
bool IsPlayingSound2D(const char* path);
void PlaySound2D(const char* path, int volume, bool loop);
void TogglePauseSound2D(const char* path);
int RandIntRange(int min, int max);
float RandFloatRange(float min, float max);
void DrawBitmap(HBITMAP bmp, int x, int y);
void DrawBitmapScaled(HBITMAP bmp, int x, int y, int w, int h);
void SaveVarIntoFile(const char* path, void* data, size_t size);
template <typename T, typename S>
T LoadSaveFile(const char* path, S& estructuraBase, T& llave);
static bool ExtractResourceToFile(const char* resourceName, const char* outPath) {
    HRSRC hRes = FindResourceA(GetModuleHandleA(NULL), resourceName, (LPCSTR)RT_RCDATA);
    if (!hRes) return false;
    
    HGLOBAL hData = LoadResource(GetModuleHandleA(NULL), hRes);
    void* pData = LockResource(hData);
    DWORD size = SizeofResource(GetModuleHandleA(NULL), hRes);

    FILE* f = fopen(outPath, "wb");
    if (!f) return false;
    fwrite(pData, 1, size, f);
    fclose(f);
    return true;
}

int RandIntRange(int min, int max) {
    if (min > max) return min;
    return min + (rand() % (max - min + 1));
}

float RandFloatRange(float min, float max) {
    float random = ((float)rand()) / (float)RAND_MAX;
    return min + random * (max - min);
}

void ClearBackground(COLORREF c) {
    HBRUSH brush = CreateSolidBrush(c);
    RECT rect = { 0, 0, baseWidth, baseHeight };
    FillRect(hdcBuffer, &rect, brush);
    DeleteObject(brush);
}

// --- Input por eventos ---
LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_ERASEBKGND: return 1; // Crucial para eliminar el parpadeo
    case WM_KEYDOWN: keys[wParam & 0xFF] = true; return 0;
    case WM_KEYUP:   keys[wParam & 0xFF] = false; return 0;
    case WM_CLOSE:   shouldClose = true; DestroyWindow(hwnd); return 0;
    case WM_DESTROY: PostQuitMessage(0); return 0;
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

// --- Inicialización y ciclo principal ---
void InitWindow(int w, int h, const char* t) {
    WNDCLASSA wc = {0}; 
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = GetModuleHandleA(NULL); 
    wc.lpszClassName = "tiny2D";
    wc.hCursor = LoadCursorA(NULL, (LPCSTR)IDC_ARROW); 
    RegisterClassA(&wc);

    // --- ESTO ES LO QUE SOLUCIONA LOS BORDES EN VENTANA ---
    RECT r = { 0, 0, w, h };
    AdjustWindowRect(&r, WS_OVERLAPPEDWINDOW, FALSE); // Calcula el tamaño total necesario
    int actualW = r.right - r.left;
    int actualH = r.bottom - r.top;

    hwnd = CreateWindowExA(0, "tiny2D", t, WS_OVERLAPPEDWINDOW, 
                           CW_USEDEFAULT, CW_USEDEFAULT, actualW, actualH, 
                           NULL, NULL, wc.hInstance, NULL);
    // ------------------------------------------------------

    hdcWindow = GetDC(hwnd); 
    hdcBuffer = CreateCompatibleDC(hdcWindow);
    hbmBuffer = CreateCompatibleBitmap(hdcWindow, w, h); 
    SelectObject(hdcBuffer, hbmBuffer);
    ShowWindow(hwnd, SW_SHOW);
}

void SetFullscreen(bool enable)
{
    if (!hwnd) return;
    if (enable == isFullscreen) return;

    if (enable)
    {
        // Guardar posición y tamaño actuales
        RECT rect;
        GetWindowRect(hwnd, &rect);
        windowedX = rect.left;
        windowedY = rect.top;
        windowedW = rect.right - rect.left;
        windowedH = rect.bottom - rect.top;

        // Obtener tamaño del monitor
        HMONITOR mon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
        MONITORINFO mi = { sizeof(mi) };
        GetMonitorInfo(mon, &mi);

        int mw = mi.rcMonitor.right - mi.rcMonitor.left;
        int mh = mi.rcMonitor.bottom - mi.rcMonitor.top;

        // Cambiar estilo a fullscreen sin bordes
        SetWindowLong(hwnd, GWL_STYLE, WS_POPUP | WS_VISIBLE);
        SetWindowPos(hwnd, HWND_TOP, mi.rcMonitor.left, mi.rcMonitor.top, mw, mh, SWP_FRAMECHANGED | SWP_SHOWWINDOW);

        screenWidth = mw;
        screenHeight = mh;
        isFullscreen = true;
    }
    else
    {
        // Restaurar estilo de ventana con bordes
        SetWindowLong(hwnd, GWL_STYLE, WS_OVERLAPPEDWINDOW | WS_VISIBLE);

        // Calcular tamaño de ventana para que el cliente sea baseWidth/baseHeight
        RECT rect = { 0, 0, baseWidth, baseHeight };
        AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);

        int winW = rect.right - rect.left;
        int winH = rect.bottom - rect.top;

        SetWindowPos(hwnd, HWND_TOP, windowedX, windowedY, winW, winH, SWP_FRAMECHANGED | SWP_SHOWWINDOW);

        screenWidth = baseWidth;
        screenHeight = baseHeight;
        isFullscreen = false;
    }

    // Recrear buffer con tamaño actual
    int bufferW = screenWidth;
    int bufferH = screenHeight;

    DeleteObject(hbmBuffer);
    hbmBuffer = CreateCompatibleBitmap(hdcWindow, bufferW, bufferH);
    SelectObject(hdcBuffer, hbmBuffer);
}

bool IsFullscreen() {
    return isFullscreen;
}

void PlaySoundFromResource(const char* resourceName, int volume /* ignorado aquí */, bool loop) {
    HRSRC hRes = FindResourceA(NULL, resourceName, (LPCSTR)RT_RCDATA);
    if (!hRes) return;

    HGLOBAL hData = LoadResource(NULL, hRes);
    void* pData = LockResource(hData);
    DWORD size = SizeofResource(NULL, hRes);

    // Bandera de loop
    DWORD flags = SND_MEMORY | SND_ASYNC;
    if (loop) flags |= SND_LOOP;

    // Reproduce directamente desde memoria
    PlaySoundA((LPCSTR)pData, NULL, flags);
}

// 1. Reproducir (Soporta MP3 y WAV)
void PlaySound2D(const char* path, int volume, bool loop) {
    char cmd[512];
    
    // 1. Cerramos por si ya estaba abierto (evita errores al re-reproducir)
    snprintf(cmd, sizeof(cmd), "close \"%s\"", path);
    mciSendStringA(cmd, NULL, 0, NULL);

    // 2. Abrir el archivo físico
    snprintf(cmd, sizeof(cmd), "open \"%s\" type mpegvideo alias \"%s\"", path, path);
    if (mciSendStringA(cmd, NULL, 0, NULL) != 0) return; // Si no existe el archivo, sale

    // 3. Ajustar volumen (Escala MCI 0-1000)
    snprintf(cmd, sizeof(cmd), "setaudio \"%s\" volume to %d", path, volume * 10);
    mciSendStringA(cmd, NULL, 0, NULL);

    // 4. Reproducir
    if (loop) {
        snprintf(cmd, sizeof(cmd), "play \"%s\" repeat", path);
    } else {
        snprintf(cmd, sizeof(cmd), "play \"%s\" from 0", path);
    }
    
    mciSendStringA(cmd, NULL, 0, NULL);
}

// 2. Pausar / Reanudar (Toggle)
void TogglePauseSound2D(const char* path) {
    char cmd[512];
    char status[128];
    
    // Consultar estado actual
    snprintf(cmd, sizeof(cmd), "status \"%s\" mode", path);
    mciSendStringA(cmd, status, sizeof(status), NULL);

    if (strcmp(status, "playing") == 0) {
        snprintf(cmd, sizeof(cmd), "pause \"%s\"", path);
    } else {
        snprintf(cmd, sizeof(cmd), "play \"%s\"", path); // Reanuda desde donde estaba
    }
    mciSendStringA(cmd, NULL, 0, NULL);
}

// 3. Detener por completo (Vuelve a 0 y cierra)
void StopSound2D(const char* path) {
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "stop \"%s\"", path);
    mciSendStringA(cmd, NULL, 0, NULL);
    snprintf(cmd, sizeof(cmd), "close \"%s\"", path);
    mciSendStringA(cmd, NULL, 0, NULL);
}

// 4. Saber si se está ejecutando
bool IsSoundPlaying2D(const char* path) {
    char cmd[512];
    char status[128];
    snprintf(cmd, sizeof(cmd), "status \"%s\" mode", path);
    mciSendStringA(cmd, status, sizeof(status), NULL);
    return (strcmp(status, "playing") == 0);
}

void CloseWindow() {
    DeleteObject(hbmBuffer); DeleteDC(hdcBuffer);
    ReleaseDC(hwnd, hdcWindow); DestroyWindow(hwnd);
}

bool WindowShouldClose() { return shouldClose; }

void EndDrawing(void) {
    RECT client; 
    GetClientRect(hwnd, &client);
    int cw = client.right - client.left;
    int ch = client.bottom - client.top;

    // SI EL TAMAÑO ES IGUAL, NO CALCULES NADA (EVITA BORDES)
    if (cw == baseWidth && ch == baseHeight) {
        BitBlt(hdcWindow, 0, 0, baseWidth, baseHeight, hdcBuffer, 0, 0, SRCCOPY);
        return;
    }

    // SOLO SI ES DIFERENTE (PANTALLA COMPLETA O RESIZE), CALCULAMOS ESCALA
    float sX = (float)cw / baseWidth;
    float sY = (float)ch / baseHeight;
    float s = (sX < sY) ? sX : sY;
    int sw = (int)(baseWidth * s);
    int sh = (int)(baseHeight * s);
    int ox = (cw - sw) / 2;
    int oy = (ch - sh) / 2;

    SetStretchBltMode(hdcWindow, HALFTONE);
    
    // Limpiar bordes solo si realmente hay espacio sobrante
    HBRUSH b = CreateSolidBrush(RGB(0,0,0));
    if (oy > 0) {
        RECT rT={0,0,cw,oy}, rB={0,oy+sh,cw,ch};
        FillRect(hdcWindow, &rT, b); FillRect(hdcWindow, &rB, b);
    }
    if (ox > 0) {
        RECT rL={0,oy,ox,oy+sh}, rR={ox+sw,oy,cw,oy+sh};
        FillRect(hdcWindow, &rL, b); FillRect(hdcWindow, &rR, b);
    }
    DeleteObject(b);

    StretchBlt(hdcWindow, ox, oy, sw, sh, hdcBuffer, 0, 0, baseWidth, baseHeight, SRCCOPY);
}

// --- Dibujo ---
void DrawPixel(int x, int y, COLORREF color) { SetPixel(hdcBuffer, x, y, color); }

void DrawLine(int x1, int y1, int x2, int y2, COLORREF color) {
    HPEN pen = CreatePen(PS_SOLID, 1, color);
    HPEN old = (HPEN)SelectObject(hdcBuffer, pen);
    MoveToEx(hdcBuffer, x1, y1, NULL); LineTo(hdcBuffer, x2, y2);
    SelectObject(hdcBuffer, old); DeleteObject(pen);
}

void DrawText2D(const char* text, int x, int y, COLORREF textColor) {
    if (!text) return;

    SetTextColor(hdcBuffer, textColor);
    SetBkMode(hdcBuffer, TRANSPARENT);

    int lineY = y;
    const char* start = text;
    const char* end = text;

    while (*end != '\0') {
        if (*end == '\n') {
            // Dibujamos el segmento hasta antes del \n
            int len = (int)(end - start);
            if (len > 0) {
                TextOutA(hdcBuffer, x, lineY, start, len);
            }
            lineY += 16;      // Salto de línea (16 píxeles suele ir bien para la fuente de sistema)
            start = end + 1;  // Empezamos la siguiente línea después del \n
        }
        end++;
    }

    // Dibujamos la última línea (o la única si no hay \n)
    int len = (int)(end - start);
    if (len > 0) {
        TextOutA(hdcBuffer, x, lineY, start, len);
    }
}

void DrawRect(int x, int y, int w, int h, COLORREF color) {
    HBRUSH brush = CreateSolidBrush(color);
    RECT r = {x, y, x + w, y + h};
    FillRect(hdcBuffer, &r, brush); DeleteObject(brush);
}

void DrawCircle(int cx, int cy, int radius, COLORREF color) {
    HPEN pen = CreatePen(PS_SOLID, 1, color);
    HPEN old = (HPEN)SelectObject(hdcBuffer, pen);
    Arc(hdcBuffer, cx - radius, cy - radius, cx + radius, cy + radius, 0, 0, 0, 0);
    SelectObject(hdcBuffer, old); DeleteObject(pen);
}

// --- Input ---
bool IsKeyDown(int vk_code) { return keys[vk_code & 0xFF]; }
bool IsKeyPressed(int vk) {
    vk &= 0xFF;
    return keys[vk] && !prevKeys[vk];
}
bool IsKeyReleased(int vk) {
    vk &= 0xFF;
    return !keys[vk] && prevKeys[vk];
}
bool IsMouseButtonDown(int button) { return (GetAsyncKeyState(button) & 0x8000) != 0; }
int GetMouseX() { POINT p; GetCursorPos(&p); ScreenToClient(hwnd, &p); return p.x; }
int GetMouseY() { POINT p; GetCursorPos(&p); ScreenToClient(hwnd, &p); return p.y; }

// --- Utilidades ---
bool CheckCollision(Rect a, Rect b) {
    return (a.x < b.x + b.w && a.x + a.w > b.x &&
            a.y < b.y + b.h && a.y + a.h > b.y);
}

// --- SISTEMA DE GUARDADO AREStudio ---

// Guarda el struct completo en el archivo
void SaveVarIntoFile(const char* path, void* data, size_t size) {
    FILE* file = fopen(path, "wb");
    if (file) {
        fwrite(data, size, 1, file);
        fclose(file);
    }
}

// Carga el archivo y devuelve el valor de la "llave" (variable) que elijas
template <typename T, typename S>
T LoadSaveFile(const char* path, S& estructuraBase, T& llave) {
    T valorLeido = 0;
    
    // Calculamos el "salto" (offset) automáticamente comparando direcciones de memoria
    size_t salto = (size_t)&llave - (size_t)&estructuraBase;

    FILE* file = fopen(path, "rb");
    if (file) {
        fseek(file, (long)salto, SEEK_SET); // Saltamos a la posición de la llave
        fread(&valorLeido, sizeof(T), 1, file);
        fclose(file);
    }
    return valorLeido; // ¡Aquí tienes tu valor devuelto!
}

HBITMAP LoadBitmapFromFile(const char* filename) {
    // 1. Intenta cargar desde archivo real
    HBITMAP bmp = (HBITMAP)LoadImageA(NULL, filename, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION);
    
    // 2. Si falla, lo busca dentro del ejecutable (recurso)
    if (!bmp) {
        bmp = (HBITMAP)LoadImageA(GetModuleHandleA(NULL), filename, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    }
    return bmp;
}

void DrawBitmap(HBITMAP bmp, int x, int y, COLORREF transparentColor) {
    if (!bmp) return;
    
    HDC hdcMem = CreateCompatibleDC(hdcBuffer);
    HBITMAP old = (HBITMAP)SelectObject(hdcMem, bmp);
    
    BITMAP bm; 
    GetObject(bmp, sizeof(bm), &bm);

    // Dibujamos 1:1 ignorando el color elegido
    TransparentBlt(hdcBuffer, x, y, bm.bmWidth, bm.bmHeight, 
                   hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, transparentColor);

    SelectObject(hdcMem, old); 
    DeleteDC(hdcMem);
}

void DrawBitmapScaled(HBITMAP bmp, int x, int y, int w, int h, COLORREF transparentColor) {
    if (!bmp) return;
    
    HDC hdcMem = CreateCompatibleDC(hdcBuffer);
    HBITMAP old = (HBITMAP)SelectObject(hdcMem, bmp);
    
    BITMAP bm; 
    GetObject(bmp, sizeof(bm), &bm);

    // Evita que se vea borroso al estirar
    SetStretchBltMode(hdcBuffer, COLORONCOLOR);

    // Dibujamos al tamaño (w, h) ignorando el color elegido
    TransparentBlt(hdcBuffer, x, y, w, h, 
                   hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, transparentColor);

    SelectObject(hdcMem, old); 
    DeleteDC(hdcMem);
}

// --- Punto de entrada universal ---
int tiny2D_Run(int width, int height, const char* title) {
    baseWidth = width;
    baseHeight = height;

    screenWidth = width;
    screenHeight = height;

    InitWindow(width, height, title);
    if (&tiny2D_Init) tiny2D_Init();

    LARGE_INTEGER freq, t1, t2;
    QueryPerformanceFrequency(&freq);
    QueryPerformanceCounter(&t1);

    const float targetFPS = 60.0f;
    const float frameTime = 1.0f / targetFPS;
    float accumulator = 0.0f;

    while (!WindowShouldClose()) {

    // 1. Guardar estado anterior ANTES de procesar mensajes
    for (int i = 0; i < 256; i++)
        prevKeys[i] = keys[i];

    // 2. Procesar mensajes (esto actualiza keys[])
    MSG msg;
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // 3. Calcular dt
    QueryPerformanceCounter(&t2);
    float dt = (float)(t2.QuadPart - t1.QuadPart) / freq.QuadPart;
    if (dt > 0.1f) dt = 0.1f;
    t1 = t2;
    accumulator += dt;

    // 4. Simular
    while (accumulator >= frameTime) {
        if (!tiny2D_Update(frameTime)) goto salir;
        accumulator -= frameTime;
    }

    // 5. Dibujar
    EndDrawing();
    Sleep(1);
    }
salir:
    CloseWindow();
    return 0;
}
